<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Falchion HP Bars</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background: radial-gradient(circle, #0a0a0a 0%, #000 100%);
      font-family: 'Segoe UI', sans-serif;
      overflow: hidden;
    }

    .battle-ui {
      display: flex;
      align-items: center;
      gap: 30px;
      position: relative;
      z-index: 10;
      padding: 80px 0;
    }

    /* VS Circle */
    .vs-circle {
      width: 80px; height: 80px;
      display: flex; justify-content: center; align-items: center;
      font: 900 18px/1 'Segoe UI', sans-serif;
      letter-spacing: 2px;
      color: #000; border-radius: 50%; border: 4px solid #fff;
      background: linear-gradient(45deg, #ffcc00 0%, #ff9900 50%, #ffcc00 100%);
      box-shadow: 0 0 20px rgba(255,204,0,0.8), 0 8px 25px rgba(0,0,0,.7), inset 0 0 15px rgba(255,255,255,0.3);
      animation: vsGlow 2s ease-in-out infinite alternate;
    }

    @keyframes vsGlow {
      0%   { box-shadow: 0 0 20px rgba(255,204,0,0.8), 0 8px 25px rgba(0,0,0,.7), inset 0 0 15px rgba(255,255,255,0.3); }
      100% { box-shadow: 0 0 30px rgba(255,204,0,1),   0 8px 25px rgba(0,0,0,.7), inset 0 0 25px rgba(255,255,255,0.5); }
    }

    /* HP container styling */
    .hp-bar-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    .hp-container {
      position: relative;
      width: 400px; height: 80px;
      background: linear-gradient(135deg, #1a1a1a 0%, #0d0d0d 100%);
      border: 2px solid rgba(255,255,255,.15);
      box-shadow: inset 0 0 20px rgba(0,0,0,.8), 0 4px 15px rgba(0,0,0,.6);
      margin: 60px 0;
    }

    /* Falchion shapes */
    .enemy .hp-container { clip-path: polygon(0 35%, 65% 35%, 75% 45%, 82% 60%, 88% 75%, 92% 85%, 96% 92%, 100% 95%, 98% 80%, 94% 65%, 88% 50%, 82% 35%, 75% 25%, 65% 18%, 0 18%); }
    .hero .hp-container  { clip-path: polygon(100% 65%, 35% 65%, 25% 55%, 18% 40%, 12% 25%, 8% 15%, 4% 8%, 0% 5%, 2% 20%, 6% 35%, 12% 50%, 18% 65%, 25% 75%, 35% 82%, 100% 82%); }

    /* HP fill */
    .hp-fill {
      position: absolute;
      top: 0;
      height: 100%;
      transition: width 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      overflow: hidden;
    }

    .enemy .hp-fill {
      left: 0;
      background: linear-gradient(90deg, #cc0000 0%, #ff4444 50%, #ff6666 100%);
    }

    .hero .hp-fill  {
      right: 0;
      background: linear-gradient(90deg, #003399 0%, #4499ff 50%, #66aaff 100%);
    }

    /* Wave effect */
    .wave {
      position: absolute;
      top: 0;
      width: 180px;
      height: 100%;
      background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.1) 15%, rgba(255,255,255,0.3) 30%, rgba(255,255,255,0.7) 45%, rgba(255,255,255,0.9) 50%, rgba(255,255,255,0.7) 55%, rgba(255,255,255,0.3) 70%, rgba(255,255,255,0.1) 85%, rgba(255,255,255,0) 100%);
      opacity: 0;
      border-radius: 4px;
      mix-blend-mode: screen;
      pointer-events: none;
      animation-duration: var(--wave-duration, 3s);
      animation-timing-function: ease-in-out;
      animation-iteration-count: infinite;
    }

    .enemy .wave { animation-name: wave-right-to-left; }
    .hero .wave  { animation-name: wave-left-to-right; }

    @keyframes wave-right-to-left { 0% { right: -180px; opacity: 0; } 10%,90% {opacity:1;} 100% { right: 400px; opacity: 0; } }
    @keyframes wave-left-to-right  { 0% { left: -180px;  opacity: 0; } 10%,90% {opacity:1;} 100% { left: 400px; opacity: 0; } }

    /* HP text positioning and styling */
    .hp-value {
      position: absolute;
      font: bold 18px 'Segoe UI', sans-serif;
      width: 60px;
      text-align: center;
      padding: 4px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(0,0,0,0.3);
      color: #fff;
      text-shadow: 0 0 8px rgba(0,0,0,0.9);
      backdrop-filter: blur(4px);
      letter-spacing: 1px;
    }

    .enemy .hp-value {
      bottom: 160px;
      left: 0;
      color: #ff6666;
      text-shadow: 0 0 8px #ff6666;
    }

    .hero .hp-value  {
      top: 160px;
      right: 0;
      color: #66aaff;
      text-shadow: 0 0 8px #66aaff;
    }

    /* Health state animations */
    .low-hp       { animation: lowHpPulse 1.5s ease-in-out infinite alternate; }
    .critical-hp  { animation: criticalFlash 0.6s ease-in-out infinite alternate; }
    .low-hp-text  { animation: lowHpTextPulse 1.2s ease-in-out infinite alternate; }
    .critical-hp-text { animation: criticalHpTextFlash 0.8s ease-in-out infinite alternate; }

    @keyframes lowHpPulse        { 0% { filter: brightness(1);} 100% {filter: brightness(1.4) drop-shadow(0 0 10px currentColor);} }
    @keyframes criticalFlash     { 0% {opacity:0.8;} 100% {opacity:1; filter: drop-shadow(0 0 15px currentColor);} }
    @keyframes lowHpTextPulse    { 0% {transform:scale(1);} 100% {transform:scale(1.05); text-shadow:0 0 15px currentColor;} }
    @keyframes criticalHpTextFlash {0%{transform:scale(1);opacity:.9;}100%{transform:scale(1.1);opacity:1;text-shadow:0 0 20px currentColor;}}
  </style>
</head>
<body>
  <div class="battle-ui">
    <!-- Enemy HP -->
    <div class="hp-bar-container enemy">
      <div class="hp-value">75%</div>
      <div class="hp-container">
        <div class="hp-fill">
          <div class="wave"></div>
        </div>
      </div>
    </div>

    <div class="vs-circle">VS</div>

    <!-- Hero HP -->
    <div class="hp-bar-container hero">
      <div class="hp-container">
        <div class="hp-fill">
          <div class="wave"></div>
        </div>
      </div>
      <div class="hp-value">50%</div>
    </div>
  </div>

  <script>
    const players = {
      enemy: { hp: 0.75, element: null },
      hero: { hp: 0.50, element: null }
    };

    // Cache DOM elements
    Object.keys(players).forEach(type => {
      const container = document.querySelector(`.${type}`);
      players[type].element = {
        bar: container.querySelector('.hp-fill'),
        value: container.querySelector('.hp-value')
      };
    });

    function updateHpBars() {
      Object.entries(players).forEach(([type, player]) => {
        const { bar, value } = player.element;
        const hpPercent = player.hp * 100;

        // Update HP display
        bar.style.width = hpPercent + "%";
        value.textContent = Math.round(hpPercent) + "%";
        bar.style.setProperty('--wave-duration', Math.max(0.4, 3 * player.hp) + "s");

        // Clear and apply health state classes
        const healthClasses = ['low-hp', 'critical-hp'];
        const textClasses = ['low-hp-text', 'critical-hp-text'];

        bar.classList.remove(...healthClasses);
        value.classList.remove(...textClasses);

        if (player.hp <= 0.15) {
          bar.classList.add('critical-hp');
          value.classList.add('critical-hp-text');
        } else if (player.hp <= 0.3) {
          bar.classList.add('low-hp');
          value.classList.add('low-hp-text');
        }
      });
    }

    setInterval(() => {
      // Random HP damage
      Object.values(players).forEach(player => {
        if (Math.random() > 0.5 && player.hp > 0) {
          player.hp = Math.max(0, player.hp - (Math.random() * 0.05 + 0.02));
        }
      });

      // Reset if both players are critically low
      if (Object.values(players).every(p => p.hp < 0.1)) {
        Object.values(players).forEach(p => p.hp = Math.random() * 0.4 + 0.6);
      }

      updateHpBars();
    }, 2500);

    updateHpBars();
  </script>
</body>
</html>

I want to integrate the stuff above in my renpy game UI (that is still incomplete)
But instead of "VS" circle, it should be the Rounds circle instead, surrounded by HP bars left and right
Do thorough research on Renpy & Python ATL on don't bother answering at all

# ========================
# Game Variables
# ========================
default current_round = 59
default max_ap = 9
default available_ap = 3

define ROUND_RADIUS = 70
define ORB_RADIUS = 15

# ========================
# ATL Transforms
# ========================
transform orb_glow:
    parallel:
        ease 1.0 alpha 0.8
        ease 1.0 alpha 1.0
    parallel:
        linear 0.1 additive 0.3
        linear 0.1 additive 0.0
    repeat

transform round_breathe:
    ease 3.0 zoom 1.05
    ease 3.0 zoom 1.0
    repeat

transform orb_inactive:
    alpha 0.4
    zoom 0.9

# ========================
# Python Helpers
# ========================
init python:
    import math

    class Circle(renpy.Displayable):
        def __init__(self, radius, color, border_color=None, border_width=2, **kwargs):
            super().__init__(**kwargs)
            self.radius, self.color = radius, color
            self.border_color, self.border_width = border_color, border_width

        def render(self, w, h, st, at):
            size = self.radius * 2
            r = renpy.Render(size, size)
            c = r.canvas()

            if self.color:
                c.circle(self.color, (self.radius, self.radius), self.radius)
            if self.border_color:
                c.circle(self.border_color, (self.radius, self.radius), self.radius, self.border_width)
            return r

    def get_orb_positions(num_orbs):
        """
        Returns orb positions arranged evenly in a circle around ROUND_RADIUS.
        Offsets by ORB_RADIUS so they align properly.
        """
        positions = []
        for i in range(num_orbs):
            angle = 2 * math.pi * i / num_orbs - math.pi/2
            x = ROUND_RADIUS * (1 + math.cos(angle)) - ORB_RADIUS
            y = ROUND_RADIUS * (1 + math.sin(angle)) - ORB_RADIUS
            positions.append((int(x), int(y)))
        return positions

# ========================
# Circle Definitions
# ========================
define round_bg = Circle(ROUND_RADIUS, (80, 80, 80), (50, 50, 50), 3)
define orb_active = Circle(ORB_RADIUS, (255, 215, 0), (184, 134, 11), 2)
define orb_inactive_img = Circle(ORB_RADIUS, (102, 102, 102), (60, 60, 60), 2)

# ========================
# Main UI Screen
# ========================
screen round_ui():
    fixed:
        xalign 0.5
        yalign 0.75
        xsize ROUND_RADIUS*2
        ysize ROUND_RADIUS*2

        # Round circle background with breathing animation
        add round_bg at round_breathe

        # Round number in the center
        vbox:
            xalign 0.5
            yalign 0.5
            spacing 2

            text "Round":
                size 22
                color "#FFFFFF"
                xalign 0.5
                outlines [(2, "#000000", 0, 0)]

            text "[current_round]":
                size 56
                color "#FFFFFF"
                xalign 0.5
                outlines [(2, "#000000", 0, 0)]

        # Orbs arranged around the circle
        for i, (x, y) in enumerate(get_orb_positions(max_ap)):
            add (orb_active if i < available_ap else orb_inactive_img) at (orb_glow if i < available_ap else orb_inactive) xpos x ypos y

# ========================
# Demo Label
# ========================
label start:
    show screen round_ui

    "Round UI Demo: Round [current_round], AP [available_ap]/[max_ap]"

    menu:
        "Spend AP" if available_ap > 0:
            $ available_ap -= 1
            jump start

        "Gain AP" if available_ap < max_ap:
            $ available_ap += 1
            jump start

        "Next Round":
            $ current_round += 1
            $ available_ap = max_ap
            jump start

        "Exit":
            return
